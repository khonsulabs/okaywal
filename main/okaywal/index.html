<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="A write-ahead log (WAL) implementation for Rust."><meta name="keywords" content="rust, rustlang, rust-lang, okaywal"><title>okaywal - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../SourceSerif4-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../FiraSans-Regular.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../FiraSans-Medium.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../SourceCodePro-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../SourceSerif4-Bold.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../SourceCodePro-Semibold.ttf.woff2"><link rel="stylesheet" href="../normalize.css"><link rel="stylesheet" href="../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" href="../ayu.css" disabled><link rel="stylesheet" href="../dark.css" disabled><link rel="stylesheet" href="../light.css" id="themeStyle"><script id="default-settings" ></script><script src="../storage.js"></script><script defer src="../crates.js"></script><script defer src="../main.js"></script><noscript><link rel="stylesheet" href="../noscript.css"></noscript><link rel="alternate icon" type="image/png" href="../favicon-16x16.png"><link rel="alternate icon" type="image/png" href="../favicon-32x32.png"><link rel="icon" type="image/svg+xml" href="../favicon.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="sidebar-logo" href="../okaywal/index.html"><div class="logo-container"><img class="rust-logo" src="../rust-logo.svg" alt="logo"></div></a><h2></h2></nav><nav class="sidebar"><a class="sidebar-logo" href="../okaywal/index.html"><div class="logo-container"><img class="rust-logo" src="../rust-logo.svg" alt="logo"></div></a><h2 class="location"><a href="#">Crate okaywal</a></h2><div class="sidebar-elems"><ul class="block"><li class="version">Version 0.1.0</li><li><a id="all-types" href="all.html">All Items</a></li></ul><section><ul class="block"><li><a href="#structs">Structs</a></li><li><a href="#enums">Enums</a></li><li><a href="#traits">Traits</a></li></ul></section></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../wheel.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1 class="fqn">Crate <a class="mod" href="#">okaywal</a><button id="copy-path" onclick="copy_path(this)" title="Copy item path to clipboard"><img src="../clipboard.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="srclink" href="../src/okaywal/lib.rs.html#1-575">source</a> · <a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class="inner">&#x2212;</span>]</a></span></div><details class="rustdoc-toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>A <a href="https://en.wikipedia.org/wiki/Write-ahead_logging">write-ahead log (WAL)</a> implementation for Rust.</p>
<blockquote>
<p>There’s The Great Wall, and then there’s this: an okay WAL.</p>
</blockquote>
<p><strong>WARNING: This crate is early in development. Please do not use in any
production projects until this has been incorporated into
<a href="https://github.com/khonsulabs/sediment">Sediment</a> and shipping as part of
<a href="https://github.com/khonsulabs/nebari">Nebari</a>. The file format is currently
considered unstable.</strong></p>
<p><img src="https://img.shields.io/badge/unsafe-forbid-success" alt="okaywal forbids unsafe code" />
<a href="https://crates.io/crates/okaywal"><img src="https://img.shields.io/crates/v/okaywal.svg" alt="crate version" /></a>
<a href="https://github.com/khonsulabs/okaywal/actions?query=workflow:Tests"><img src="https://img.shields.io/github/actions/workflow/status/khonsulabs/okaywal/rust.yml?branch=main" alt="Live Build Status" /></a>
<a href="https://khonsulabs.github.io/okaywal/coverage/"><img src="https://khonsulabs.github.io/okaywal/coverage/badge.svg" alt="HTML Coverage Report for main branch" /></a>
<a href="https://khonsulabs.github.io/okaywal/main/okaywal"><img src="https://img.shields.io/badge/docs-main-informational" alt="Documentation" /></a></p>
<p>This crate exposes a WAL that supports:</p>
<ul>
<li>Atomic and Durable writes from multiple threads.</li>
<li>Random access for previously written data.</li>
<li>Automatic checkpointing to allow reusing disk space and
preventing the WAL from growing too large.</li>
<li>Interactive recovery process with basic data versioning support.</li>
</ul>
<h3 id="basic-how-to"><a href="#basic-how-to">Basic How-To</a></h3>
<p><a href="struct.WriteAheadLog.html#method.recover"><code>WriteAheadLog::recover()</code></a> is used to create or recover a WAL
in a given directory. To open a log, an implementator of
<a href="trait.LogManager.html"><code>LogManager</code></a> must be provided. This trait is how
OkayWAL communicates with your code when recovering or checkpointing a log.</p>
<p>The <a href="https://github.com/khonsulabs/okaywal/blob/main/examples/basic.rs">basic example</a> shows this process with many comments
describing how OkayWAL works.</p>

<div class="example-wrap ignore"><div class='tooltip'>ⓘ</div><pre class="rust rust-example-rendered"><code><span class="comment">// Open a log using an Checkpointer that echoes the information passed into each
// function that the Checkpointer trait defines.
</span><span class="kw">let </span>log = WriteAheadLog::recover(<span class="string">&quot;my-log&quot;</span>, LoggingCheckpointer)<span class="question-mark">?</span>;

<span class="comment">// Begin writing an entry to the log.
</span><span class="kw">let </span><span class="kw-2">mut </span>writer = log.begin_entry()<span class="question-mark">?</span>;

<span class="comment">// Each entry is one or more chunks of data. Each chunk can be individually
// addressed using its LogPosition.
</span><span class="kw">let </span>record = writer.write_chunk(<span class="string">&quot;this is the first entry&quot;</span>.as_bytes())<span class="question-mark">?</span>;

<span class="comment">// To fully flush all written bytes to disk and make the new entry
// resilliant to a crash, the writer must be committed.
</span>writer.commit()<span class="question-mark">?</span>;</code></pre></div>
<h3 id="multi-threaded-writing"><a href="#multi-threaded-writing">Multi-Threaded Writing</a></h3>
<p>Optimized writing to the log from multiple threads is handled automatically.
Only one thread may access the active log file at any moment in time. Because
the slowest part of writing data to disk is <code>fsync</code>, OkayWAL manages
synchronizing multiple writers such that a single <code>fsync</code> call can be made for
multiple writes.</p>
<p>This can be demonstrated by running the benchmark suite: <code>cargo bench -p benchmarks</code>:</p>
<h4 id="commit-256b"><a href="#commit-256b">commit-256B</a></h4><div><table><thead><tr><th>Label</th><th>avg</th><th>min</th><th>max</th><th>stddev</th><th>out%</th></tr></thead><tbody>
<tr><td>okaywal-01t</td><td>1.001ms</td><td>617.5us</td><td>7.924ms</td><td>557.3us</td><td>0.016%</td></tr>
<tr><td>okaywal-02t</td><td>1.705ms</td><td>617.3us</td><td>11.38ms</td><td>912.1us</td><td>0.006%</td></tr>
<tr><td>okaywal-04t</td><td>1.681ms</td><td>622.4us</td><td>9.688ms</td><td>671.4us</td><td>0.021%</td></tr>
<tr><td>okaywal-08t</td><td>1.805ms</td><td>656.5us</td><td>13.88ms</td><td>1.001ms</td><td>0.014%</td></tr>
<tr><td>okaywal-16t</td><td>1.741ms</td><td>643.2us</td><td>7.895ms</td><td>796.4us</td><td>0.028%</td></tr>
</tbody></table>
</div><h4 id="commit-1kb"><a href="#commit-1kb">commit-1KB</a></h4><div><table><thead><tr><th>Label</th><th>avg</th><th>min</th><th>max</th><th>stddev</th><th>out%</th></tr></thead><tbody>
<tr><td>okaywal-01t</td><td>959.3us</td><td>621.9us</td><td>7.419ms</td><td>584.4us</td><td>0.012%</td></tr>
<tr><td>okaywal-02t</td><td>1.569ms</td><td>627.5us</td><td>7.986ms</td><td>1.007ms</td><td>0.028%</td></tr>
<tr><td>okaywal-04t</td><td>1.856ms</td><td>650.5us</td><td>11.14ms</td><td>1.087ms</td><td>0.017%</td></tr>
<tr><td>okaywal-08t</td><td>2.054ms</td><td>697.3us</td><td>11.04ms</td><td>1.066ms</td><td>0.021%</td></tr>
<tr><td>okaywal-16t</td><td>1.875ms</td><td>641.5us</td><td>8.193ms</td><td>674.6us</td><td>0.032%</td></tr>
</tbody></table>
</div><h4 id="commit-4kb"><a href="#commit-4kb">commit-4KB</a></h4><div><table><thead><tr><th>Label</th><th>avg</th><th>min</th><th>max</th><th>stddev</th><th>out%</th></tr></thead><tbody>
<tr><td>okaywal-01t</td><td>1.242ms</td><td>748.8us</td><td>6.902ms</td><td>982.4us</td><td>0.008%</td></tr>
<tr><td>okaywal-02t</td><td>1.767ms</td><td>761.9us</td><td>8.986ms</td><td>902.1us</td><td>0.016%</td></tr>
<tr><td>okaywal-04t</td><td>2.347ms</td><td>787.1us</td><td>8.853ms</td><td>1.084ms</td><td>0.016%</td></tr>
<tr><td>okaywal-08t</td><td>2.798ms</td><td>810.8us</td><td>12.53ms</td><td>1.168ms</td><td>0.014%</td></tr>
<tr><td>okaywal-16t</td><td>2.151ms</td><td>840.5us</td><td>14.74ms</td><td>1.201ms</td><td>0.008%</td></tr>
</tbody></table>
</div><h4 id="commit-1mb"><a href="#commit-1mb">commit-1MB</a></h4><div><table><thead><tr><th>Label</th><th>avg</th><th>min</th><th>max</th><th>stddev</th><th>out%</th></tr></thead><tbody>
<tr><td>okaywal-01t</td><td>7.018ms</td><td>5.601ms</td><td>9.865ms</td><td>788.2us</td><td>0.027%</td></tr>
<tr><td>okaywal-02t</td><td>11.06ms</td><td>4.281ms</td><td>20.14ms</td><td>3.521ms</td><td>0.000%</td></tr>
<tr><td>okaywal-04t</td><td>19.77ms</td><td>5.094ms</td><td>73.21ms</td><td>8.794ms</td><td>0.007%</td></tr>
<tr><td>okaywal-08t</td><td>25.06ms</td><td>2.871ms</td><td>97.60ms</td><td>17.33ms</td><td>0.002%</td></tr>
<tr><td>okaywal-16t</td><td>19.01ms</td><td>3.480ms</td><td>58.85ms</td><td>7.195ms</td><td>0.014%</td></tr>
</tbody></table>
</div>
<p>These numbers are the time taken for a single thread to perform an atomic and
durable write of a given size to the log file. Despite using a single-file
approach, we are able to keep average write times very low even with a large
number of simultaneous writers.</p>
<h3 id="how-okaywal-works"><a href="#how-okaywal-works">How OkayWAL works</a></h3>
<p>OkayWAL streams incoming data into “segments”. Each segment file is named with
the format <code>wal-{id}</code>. The id of a segment file refers to the first <code>EntryId</code>
that could appear within the segment file.</p>
<p>Segment files are pre-allocated to the length configured in
<code>Configuration::preallocate_bytes</code>. Preallocating files is critical for
performance, as overwriting existing bytes in general is less expensive than
allocating new bytes on disk.</p>
<p>OkayWAL always has a current segment file. When a new entry is written, it
always goes to the current segment file. When an entry is completed, the length
of the segment file is checked against <code>Configuration::checkpoint_after_bytes</code>.
If enough data has been written to trigger a checkpoint, the file is sent to the
checkpointing thread and a new segment file is activated.</p>
<p>Regardless of whether the file is checkpointed, before control returns from
committing an entry, the file is <code>fsync</code>ed. <code>fsync</code> operations are batched,
allowing multiple entries to be written by separate threads during the same
<code>fsync</code> operation.</p>
<p>OkayWAL also keeps track of any time a new file is created or a file is renamed.
As needed, the directory containing the write-ahead logs is also <code>fsync</code>ed to
ensure necessary file and directory metadata is fully synchronized. Just like
file <code>fsync</code> batching, OkayWAL also automatically batches directory <code>fsync</code>s
across threads.</p>
<h4 id="checkpointing-a-segment-file-background-thread"><a href="#checkpointing-a-segment-file-background-thread">Checkpointing a segment file (Background Thread)</a></h4>
<p>The checkpointing thread holds a weak reference to the <code>WriteAheadLog</code> data.
When a file is received by the thread to checkpoint, it will upgrade the weak
reference. If it cannot, the checkpointing thread shuts down gracefully and the
recovery process will send the file again for checkpointing the next time the
log is opened.</p>
<p>The thread invokes <code>LogManager::checkpoint_to</code> for the file, allowing the
<code>LogManager</code> to make any needed changes to persist the data stored in the
segment being checkpointed.</p>
<p>After the <code>LogManager</code> finishes, the file is renamed to include <code>-cp</code> as its
suffix. Until this step, readers are able to be opened against data stored in
the file being checkpointed. Once the file is renamed, new readers will begin
returning not found errors.</p>
<p>After the file is renamed, the checkpointer waits for all outstanding readers to
finish reading data. The file is then finally recycled by moving it to the
inactive files list.</p>
<h4 id="activating-a-new-segment-file"><a href="#activating-a-new-segment-file">Activating a new segment file</a></h4>
<p>If there are any files in the inactive files list, one is reused. Otherwise, a
new file is created and filled with 0’s to the configured preallocation length.</p>
<p>The file’s name is set to <code>wal-{next EntryId}</code>. For example, a brand new
write-ahead log’s first segment file will be named <code>wal-1</code>, and the first
<code>EntryId</code> written will be <code>1</code>.</p>
<h4 id="segment-file-format"><a href="#segment-file-format">Segment File Format</a></h4>
<p>Each segment file starts with this header:</p>
<ul>
<li><code>okw</code>: Three byte magic code</li>
<li>OkayWAL Version: Single byte version number. Currently 0.</li>
<li><code>Configuration::version_info</code> length: Single byte. The embedded information
must be 255 or less bytes long.</li>
<li>Embedded Version Info: The bytes of the version info. The previous byte
controls how many bytes long this field is.</li>
</ul>
<p>After this header, the file is a series of entries, each which contain a series
of chunks. A byte with a value of 1 signifies a new entry. Any other byte causes
the reader to stop reading entries from the file.</p>
<p>The first 8 bytes of the entry is the little-endian representation of its
<code>EntryId</code>.</p>
<p>After the <code>EntryId</code>, a series of chunks is expected. A byte with a value of 2
signals that a chunk is next in the file. A byte with a value of 3 signals that
this is the end of the current entry being written. Any other byte causes the
<code>SegmentReader</code> to return an AbortedEntry result. Any already-read chunks from
this entry should be ignored/rolled back by the <code>LogManager</code>.</p>
<p>The first four bytes of a chunk is the data length in little-endian
representation. The data for the chunk follows.</p>
<p>Finally, a four-byte crc32 ends the chunk.</p>
<p>If a reader does not encounter a new chunk marker (2) or an end-of-entry marker
(3), the entry should be considered abandoned and all chunks should be ignored.</p>
</div></details><h2 id="structs" class="small-section-header"><a href="#structs">Structs</a></h2><div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.ChunkReader.html" title="okaywal::ChunkReader struct">ChunkReader</a></div><div class="item-right docblock-short">A buffered reader for a previously written data chunk.</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.ChunkRecord.html" title="okaywal::ChunkRecord struct">ChunkRecord</a></div><div class="item-right docblock-short">A record of a chunk that was written to a <a href="struct.WriteAheadLog.html" title="WriteAheadLog"><code>WriteAheadLog</code></a>.</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.Configuration.html" title="okaywal::Configuration struct">Configuration</a></div><div class="item-right docblock-short">A <a href="struct.WriteAheadLog.html" title="WriteAheadLog"><code>WriteAheadLog</code></a> configuration.</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.Entry.html" title="okaywal::Entry struct">Entry</a></div><div class="item-right docblock-short">A stored entry inside of a <a href="struct.WriteAheadLog.html"><code>WriteAheadLog</code></a>.</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.EntryChunk.html" title="okaywal::EntryChunk struct">EntryChunk</a></div><div class="item-right docblock-short">A chunk of data previously written using
<a href="struct.EntryWriter.html#method.write_chunk"><code>EntryWriter::write_chunk</code></a>.</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.EntryId.html" title="okaywal::EntryId struct">EntryId</a></div><div class="item-right docblock-short">The unique id of an entry written to a <a href="struct.WriteAheadLog.html" title="WriteAheadLog"><code>WriteAheadLog</code></a>. These IDs are
ordered by the time the <a href="struct.EntryWriter.html" title="EntryWriter"><code>EntryWriter</code></a> was created for the entry written with this id.</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.EntryWriter.html" title="okaywal::EntryWriter struct">EntryWriter</a></div><div class="item-right docblock-short">A writer for an entry in a <a href="struct.WriteAheadLog.html" title="WriteAheadLog"><code>WriteAheadLog</code></a>.</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.LogPosition.html" title="okaywal::LogPosition struct">LogPosition</a></div><div class="item-right docblock-short">The position of a chunk of data within a <a href="struct.WriteAheadLog.html" title="WriteAheadLog"><code>WriteAheadLog</code></a>.</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.LogVoid.html" title="okaywal::LogVoid struct">LogVoid</a></div><div class="item-right docblock-short">A <a href="trait.LogManager.html" title="LogManager"><code>LogManager</code></a> that does not attempt to recover any existing data.</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.RecoveredSegment.html" title="okaywal::RecoveredSegment struct">RecoveredSegment</a></div><div class="item-right docblock-short">Information about an individual segment of a
<a href="struct.WriteAheadLog.html"><code>WriteAheadLog</code></a> that is being recovered.</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.SegmentReader.html" title="okaywal::SegmentReader struct">SegmentReader</a></div><div class="item-right docblock-short">Reads a log segment, which contains one or more log entries.</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.WriteAheadLog.html" title="okaywal::WriteAheadLog struct">WriteAheadLog</a></div><div class="item-right docblock-short">A <a href="https://en.wikipedia.org/wiki/Write-ahead_logging">Write-Ahead Log</a> that provides atomic and durable writes.</div></div></div><h2 id="enums" class="small-section-header"><a href="#enums">Enums</a></h2><div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="enum" href="enum.ReadChunkResult.html" title="okaywal::ReadChunkResult enum">ReadChunkResult</a></div><div class="item-right docblock-short">The result of reading a chunk from a log segment.</div></div><div class="item-row"><div class="item-left module-item"><a class="enum" href="enum.Recovery.html" title="okaywal::Recovery enum">Recovery</a></div><div class="item-right docblock-short">Determines whether to recover a segment or not.</div></div></div><h2 id="traits" class="small-section-header"><a href="#traits">Traits</a></h2><div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="trait" href="trait.LogManager.html" title="okaywal::LogManager trait">LogManager</a></div><div class="item-right docblock-short">Customizes recovery and checkpointing behavior for a
<a href="struct.WriteAheadLog.html"><code>WriteAheadLog</code></a>.</div></div></div></section></div></main><div id="rustdoc-vars" data-root-path="../" data-current-crate="okaywal" data-themes="ayu,dark,light" data-resource-suffix="" data-rustdoc-version="1.66.0 (69f9c33d7 2022-12-12)" ></div></body></html>