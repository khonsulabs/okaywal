<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="A write-ahead log (WAL) implementation for Rust."><title>okaywal - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Bold-a2c9cd1067f8b328.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-fa3bb1812debf86c.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="okaywal" data-themes="" data-resource-suffix="" data-rustdoc-version="1.74.0 (79e9716c9 2023-11-13)" data-channel="1.74.0" data-search-js="search-8be46b629f5f14a8.js" data-settings-js="settings-74424d7eec62a23e.js" ><script src="../static.files/storage-fec3eaa3851e447d.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-c5bd66d33317d69f.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-5d8b3c7633ad77ba.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="logo-container" href="../okaywal/index.html"><img class="rust-logo" src="../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a></nav><nav class="sidebar"><a class="logo-container" href="../okaywal/index.html"><img class="rust-logo" src="../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2 class="location"><a href="#">Crate okaywal</a></h2><div class="sidebar-elems"><ul class="block"><li class="version">Version 0.3.1</li><li><a id="all-types" href="all.html">All Items</a></li></ul><section><ul class="block"><li><a href="#reexports">Re-exports</a></li><li><a href="#structs">Structs</a></li><li><a href="#enums">Enums</a></li><li><a href="#traits">Traits</a></li></ul></section></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Crate <a class="mod" href="#">okaywal</a><button id="copy-path" title="Copy item path to clipboard"><img src="../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="src" href="../src/okaywal/lib.rs.html#1-671">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>A <a href="https://en.wikipedia.org/wiki/Write-ahead_logging">write-ahead log (WAL)</a> implementation for Rust.</p>
<blockquote>
<p>There’s The Great Wall, and then there’s this: an okay WAL.</p>
</blockquote>
<p><strong>WARNING: This crate is early in development. Please do not use in any
production projects until this has been incorporated into
<a href="https://github.com/khonsulabs/sediment">Sediment</a> and shipping as part of
<a href="https://github.com/khonsulabs/nebari">Nebari</a>. The file format is currently
considered unstable.</strong></p>
<p><img src="https://img.shields.io/badge/unsafe-forbid-success" alt="okaywal forbids unsafe code" />
<a href="https://crates.io/crates/okaywal"><img src="https://img.shields.io/crates/v/okaywal.svg" alt="crate version" /></a>
<a href="https://github.com/khonsulabs/okaywal/actions?query=workflow:Tests"><img src="https://img.shields.io/github/actions/workflow/status/khonsulabs/okaywal/rust.yml?branch=main" alt="Live Build Status" /></a>
<a href="https://khonsulabs.github.io/okaywal/coverage/"><img src="https://khonsulabs.github.io/okaywal/coverage/badge.svg" alt="HTML Coverage Report for main branch" /></a>
<a href="https://khonsulabs.github.io/okaywal/main/okaywal"><img src="https://img.shields.io/badge/docs-main-informational" alt="Documentation" /></a></p>
<p>This crate exposes a WAL that supports:</p>
<ul>
<li>Atomic and Durable writes from multiple threads.</li>
<li>Random access for previously written data.</li>
<li>Automatic checkpointing to allow reusing disk space and
preventing the WAL from growing too large.</li>
<li>Interactive recovery process with basic data versioning support.</li>
</ul>
<h3 id="basic-how-to"><a href="#basic-how-to">Basic How-To</a></h3>
<p><a href="struct.WriteAheadLog.html#method.recover" title="associated function okaywal::WriteAheadLog::recover"><code>WriteAheadLog::recover()</code></a> is used to create or recover a WAL
in a given directory. To open a log, an implementer of
<a href="trait.LogManager.html" title="trait okaywal::LogManager"><code>LogManager</code></a> must be provided. This trait is how
OkayWAL communicates with your code when recovering or checkpointing a log.</p>
<p>The <a href="https://github.com/khonsulabs/okaywal/blob/main/examples/basic.rs">basic example</a> shows this process with many comments
describing how OkayWAL works.</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="comment">// Open a log using a Checkpointer that echoes the information passed into each
// function that the Checkpointer trait defines.
</span><span class="kw">let </span>log = WriteAheadLog::recover(<span class="string">&quot;my-log&quot;</span>, LoggingCheckpointer)<span class="question-mark">?</span>;

<span class="comment">// Begin writing an entry to the log.
</span><span class="kw">let </span><span class="kw-2">mut </span>writer = log.begin_entry()<span class="question-mark">?</span>;

<span class="comment">// Each entry is one or more chunks of data. Each chunk can be individually
// addressed using its LogPosition.
</span><span class="kw">let </span>record = writer.write_chunk(<span class="string">&quot;this is the first entry&quot;</span>.as_bytes())<span class="question-mark">?</span>;

<span class="comment">// To fully flush all written bytes to disk and make the new entry
// resilient to a crash, the writer must be committed.
</span>writer.commit()<span class="question-mark">?</span>;</code></pre></div>
<h3 id="multi-threaded-writing"><a href="#multi-threaded-writing">Multi-Threaded Writing</a></h3>
<p>Optimized writing to the log from multiple threads is handled automatically.
Only one thread may access the active log file at any moment in time. Because
the slowest part of writing data to disk is <code>fsync</code>, OkayWAL manages
synchronizing multiple writers such that a single <code>fsync</code> call can be made for
multiple writes.</p>
<p>This can be demonstrated by running the benchmark suite: <code>cargo bench -p benchmarks</code>:</p>
<h4 id="commit-256b"><a href="#commit-256b">commit-256B</a></h4><div><table><thead><tr><th>Label</th><th>avg</th><th>min</th><th>max</th><th>stddev</th><th>out%</th></tr></thead><tbody>
<tr><td>okaywal-01t</td><td>1.001ms</td><td>617.5us</td><td>7.924ms</td><td>557.3us</td><td>0.016%</td></tr>
<tr><td>okaywal-02t</td><td>1.705ms</td><td>617.3us</td><td>11.38ms</td><td>912.1us</td><td>0.006%</td></tr>
<tr><td>okaywal-04t</td><td>1.681ms</td><td>622.4us</td><td>9.688ms</td><td>671.4us</td><td>0.021%</td></tr>
<tr><td>okaywal-08t</td><td>1.805ms</td><td>656.5us</td><td>13.88ms</td><td>1.001ms</td><td>0.014%</td></tr>
<tr><td>okaywal-16t</td><td>1.741ms</td><td>643.2us</td><td>7.895ms</td><td>796.4us</td><td>0.028%</td></tr>
</tbody></table>
</div><h4 id="commit-1kb"><a href="#commit-1kb">commit-1KB</a></h4><div><table><thead><tr><th>Label</th><th>avg</th><th>min</th><th>max</th><th>stddev</th><th>out%</th></tr></thead><tbody>
<tr><td>okaywal-01t</td><td>959.3us</td><td>621.9us</td><td>7.419ms</td><td>584.4us</td><td>0.012%</td></tr>
<tr><td>okaywal-02t</td><td>1.569ms</td><td>627.5us</td><td>7.986ms</td><td>1.007ms</td><td>0.028%</td></tr>
<tr><td>okaywal-04t</td><td>1.856ms</td><td>650.5us</td><td>11.14ms</td><td>1.087ms</td><td>0.017%</td></tr>
<tr><td>okaywal-08t</td><td>2.054ms</td><td>697.3us</td><td>11.04ms</td><td>1.066ms</td><td>0.021%</td></tr>
<tr><td>okaywal-16t</td><td>1.875ms</td><td>641.5us</td><td>8.193ms</td><td>674.6us</td><td>0.032%</td></tr>
</tbody></table>
</div><h4 id="commit-4kb"><a href="#commit-4kb">commit-4KB</a></h4><div><table><thead><tr><th>Label</th><th>avg</th><th>min</th><th>max</th><th>stddev</th><th>out%</th></tr></thead><tbody>
<tr><td>okaywal-01t</td><td>1.242ms</td><td>748.8us</td><td>6.902ms</td><td>982.4us</td><td>0.008%</td></tr>
<tr><td>okaywal-02t</td><td>1.767ms</td><td>761.9us</td><td>8.986ms</td><td>902.1us</td><td>0.016%</td></tr>
<tr><td>okaywal-04t</td><td>2.347ms</td><td>787.1us</td><td>8.853ms</td><td>1.084ms</td><td>0.016%</td></tr>
<tr><td>okaywal-08t</td><td>2.798ms</td><td>810.8us</td><td>12.53ms</td><td>1.168ms</td><td>0.014%</td></tr>
<tr><td>okaywal-16t</td><td>2.151ms</td><td>840.5us</td><td>14.74ms</td><td>1.201ms</td><td>0.008%</td></tr>
</tbody></table>
</div><h4 id="commit-1mb"><a href="#commit-1mb">commit-1MB</a></h4><div><table><thead><tr><th>Label</th><th>avg</th><th>min</th><th>max</th><th>stddev</th><th>out%</th></tr></thead><tbody>
<tr><td>okaywal-01t</td><td>7.018ms</td><td>5.601ms</td><td>9.865ms</td><td>788.2us</td><td>0.027%</td></tr>
<tr><td>okaywal-02t</td><td>11.06ms</td><td>4.281ms</td><td>20.14ms</td><td>3.521ms</td><td>0.000%</td></tr>
<tr><td>okaywal-04t</td><td>19.77ms</td><td>5.094ms</td><td>73.21ms</td><td>8.794ms</td><td>0.007%</td></tr>
<tr><td>okaywal-08t</td><td>25.06ms</td><td>2.871ms</td><td>97.60ms</td><td>17.33ms</td><td>0.002%</td></tr>
<tr><td>okaywal-16t</td><td>19.01ms</td><td>3.480ms</td><td>58.85ms</td><td>7.195ms</td><td>0.014%</td></tr>
</tbody></table>
</div>
<p>These numbers are the time taken for a single thread to perform an atomic and
durable write of a given size to the log file. Despite using a single-file
approach, we are able to keep average write times very low even with a large
number of simultaneous writers.</p>
<h3 id="how-okaywal-works"><a href="#how-okaywal-works">How OkayWAL works</a></h3>
<p>OkayWAL streams incoming data into “segments”. Each segment file is named with
the format <code>wal-{id}</code>. The id of a segment file refers to the first <code>EntryId</code>
that could appear within the segment file.</p>
<p>Segment files are pre-allocated to the length configured in
<code>Configuration::preallocate_bytes</code>. Preallocating files is critical for
performance, as overwriting existing bytes in general is less expensive than
allocating new bytes on disk.</p>
<p>OkayWAL always has a current segment file. When a new entry is written, it
always goes to the current segment file. When an entry is completed, the length
of the segment file is checked against <code>Configuration::checkpoint_after_bytes</code>.
If enough data has been written to trigger a checkpoint, the file is sent to the
checkpointing thread and a new segment file is activated.</p>
<p>Regardless of whether the file is checkpointed, before control returns from
committing an entry, the file is <code>fsync</code>ed. <code>fsync</code> operations are batched,
allowing multiple entries to be written by separate threads during the same
<code>fsync</code> operation.</p>
<p>OkayWAL also keeps track of any time a new file is created or a file is renamed.
As needed, the directory containing the write-ahead logs is also <code>fsync</code>ed to
ensure necessary file and directory metadata is fully synchronized. Just like
file <code>fsync</code> batching, OkayWAL also automatically batches directory <code>fsync</code>s
across threads.</p>
<h4 id="checkpointing-a-segment-file-background-thread"><a href="#checkpointing-a-segment-file-background-thread">Checkpointing a segment file (Background Thread)</a></h4>
<p>The checkpointing thread holds a weak reference to the <code>WriteAheadLog</code> data.
When a file is received by the thread to checkpoint, it will upgrade the weak
reference. If it cannot, the checkpointing thread shuts down gracefully and the
recovery process will send the file again for checkpointing the next time the
log is opened.</p>
<p>The thread invokes <code>LogManager::checkpoint_to</code> for the file, allowing the
<code>LogManager</code> to make any needed changes to persist the data stored in the
segment being checkpointed.</p>
<p>After the <code>LogManager</code> finishes, the file is renamed to include <code>-cp</code> as its
suffix. Until this step, readers are able to be opened against data stored in
the file being checkpointed. Once the file is renamed, new readers will begin
returning not found errors.</p>
<p>After the file is renamed, the checkpointer waits for all outstanding readers to
finish reading data. The file is then finally recycled by moving it to the
inactive files list.</p>
<h4 id="activating-a-new-segment-file"><a href="#activating-a-new-segment-file">Activating a new segment file</a></h4>
<p>If there are any files in the inactive files list, one is reused. Otherwise, a
new file is created and filled with 0’s to the configured preallocation length.</p>
<p>The file’s name is set to <code>wal-{next EntryId}</code>. For example, a brand new
write-ahead log’s first segment file will be named <code>wal-1</code>, and the first
<code>EntryId</code> written will be <code>1</code>.</p>
<h4 id="segment-file-format"><a href="#segment-file-format">Segment File Format</a></h4>
<p>Each segment file starts with this header:</p>
<ul>
<li><code>okw</code>: Three byte magic code</li>
<li>OkayWAL Version: Single byte version number. Currently 0.</li>
<li><code>Configuration::version_info</code> length: Single byte. The embedded information
must be 255 or less bytes long.</li>
<li>Embedded Version Info: The bytes of the version info. The previous byte
controls how many bytes long this field is.</li>
</ul>
<p>After this header, the file is a series of entries, each which contain a series
of chunks. A byte with a value of 1 signifies a new entry. Any other byte causes
the reader to stop reading entries from the file.</p>
<p>The first 8 bytes of the entry are the little-endian representation of its
<code>EntryId</code>.</p>
<p>After the <code>EntryId</code>, a series of chunks is expected. A byte with a value of 2
signals that a chunk is next in the file. A byte with a value of 3 signals that
this is the end of the current entry being written. Any other byte causes the
<code>SegmentReader</code> to return an AbortedEntry result. Any already-read chunks from
this entry should be ignored/rolled back by the <code>LogManager</code>.</p>
<p>The first four bytes of a chunk are the data length in little-endian
representation. The data for the chunk follows.</p>
<p>Finally, a four-byte CRC-32 ends the chunk.</p>
<p>If a reader does not encounter a new chunk marker (2) or an end-of-entry marker
(3), the entry should be considered abandoned and all chunks should be ignored.</p>
</div></details><h2 id="reexports" class="small-section-header"><a href="#reexports">Re-exports</a></h2><ul class="item-table"><li><div class="item-name" id="reexport.file_manager"><code>pub use file_manager;</code></div></li></ul><h2 id="structs" class="small-section-header"><a href="#structs">Structs</a></h2><ul class="item-table"><li><div class="item-name"><a class="struct" href="struct.ChunkReader.html" title="struct okaywal::ChunkReader">ChunkReader</a></div><div class="desc docblock-short">A buffered reader for a previously written data chunk.</div></li><li><div class="item-name"><a class="struct" href="struct.ChunkRecord.html" title="struct okaywal::ChunkRecord">ChunkRecord</a></div><div class="desc docblock-short">A record of a chunk that was written to a <a href="struct.WriteAheadLog.html" title="struct okaywal::WriteAheadLog"><code>WriteAheadLog</code></a>.</div></li><li><div class="item-name"><a class="struct" href="struct.Configuration.html" title="struct okaywal::Configuration">Configuration</a></div><div class="desc docblock-short">A <a href="struct.WriteAheadLog.html" title="struct okaywal::WriteAheadLog"><code>WriteAheadLog</code></a> configuration.</div></li><li><div class="item-name"><a class="struct" href="struct.Entry.html" title="struct okaywal::Entry">Entry</a></div><div class="desc docblock-short">A stored entry inside of a <a href="struct.WriteAheadLog.html" title="struct okaywal::WriteAheadLog"><code>WriteAheadLog</code></a>.</div></li><li><div class="item-name"><a class="struct" href="struct.EntryChunk.html" title="struct okaywal::EntryChunk">EntryChunk</a></div><div class="desc docblock-short">A chunk of data previously written using
<a href="struct.EntryWriter.html#method.write_chunk" title="method okaywal::EntryWriter::write_chunk"><code>EntryWriter::write_chunk</code></a>.</div></li><li><div class="item-name"><a class="struct" href="struct.EntryId.html" title="struct okaywal::EntryId">EntryId</a></div><div class="desc docblock-short">The unique id of an entry written to a <a href="struct.WriteAheadLog.html" title="struct okaywal::WriteAheadLog"><code>WriteAheadLog</code></a>. These IDs are
ordered by the time the <a href="struct.EntryWriter.html" title="struct okaywal::EntryWriter"><code>EntryWriter</code></a> was created for the entry written with this id.</div></li><li><div class="item-name"><a class="struct" href="struct.EntryWriter.html" title="struct okaywal::EntryWriter">EntryWriter</a></div><div class="desc docblock-short">A writer for an entry in a <a href="struct.WriteAheadLog.html" title="struct okaywal::WriteAheadLog"><code>WriteAheadLog</code></a>.</div></li><li><div class="item-name"><a class="struct" href="struct.LogPosition.html" title="struct okaywal::LogPosition">LogPosition</a></div><div class="desc docblock-short">The position of a chunk of data within a <a href="struct.WriteAheadLog.html" title="struct okaywal::WriteAheadLog"><code>WriteAheadLog</code></a>.</div></li><li><div class="item-name"><a class="struct" href="struct.LogVoid.html" title="struct okaywal::LogVoid">LogVoid</a></div><div class="desc docblock-short">A <a href="trait.LogManager.html" title="trait okaywal::LogManager"><code>LogManager</code></a> that does not attempt to recover any existing data.</div></li><li><div class="item-name"><a class="struct" href="struct.RecoveredSegment.html" title="struct okaywal::RecoveredSegment">RecoveredSegment</a></div><div class="desc docblock-short">Information about an individual segment of a
<a href="struct.WriteAheadLog.html" title="struct okaywal::WriteAheadLog"><code>WriteAheadLog</code></a> that is being recovered.</div></li><li><div class="item-name"><a class="struct" href="struct.SegmentReader.html" title="struct okaywal::SegmentReader">SegmentReader</a></div><div class="desc docblock-short">Reads a log segment, which contains one or more log entries.</div></li><li><div class="item-name"><a class="struct" href="struct.WriteAheadLog.html" title="struct okaywal::WriteAheadLog">WriteAheadLog</a></div><div class="desc docblock-short">A <a href="https://en.wikipedia.org/wiki/Write-ahead_logging">Write-Ahead Log</a> that provides atomic and durable writes.</div></li></ul><h2 id="enums" class="small-section-header"><a href="#enums">Enums</a></h2><ul class="item-table"><li><div class="item-name"><a class="enum" href="enum.ReadChunkResult.html" title="enum okaywal::ReadChunkResult">ReadChunkResult</a></div><div class="desc docblock-short">The result of reading a chunk from a log segment.</div></li><li><div class="item-name"><a class="enum" href="enum.Recovery.html" title="enum okaywal::Recovery">Recovery</a></div><div class="desc docblock-short">Determines whether to recover a segment or not.</div></li></ul><h2 id="traits" class="small-section-header"><a href="#traits">Traits</a></h2><ul class="item-table"><li><div class="item-name"><a class="trait" href="trait.LogManager.html" title="trait okaywal::LogManager">LogManager</a></div><div class="desc docblock-short">Customizes recovery and checkpointing behavior for a
<a href="struct.WriteAheadLog.html" title="struct okaywal::WriteAheadLog"><code>WriteAheadLog</code></a>.</div></li></ul></section></div></main></body></html>